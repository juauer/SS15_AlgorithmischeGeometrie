% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

\documentclass[a4paper, titlepage=false, parskip=full-, 10pt]{scrartcl}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english, ngerman]{babel}
\usepackage{babelbib}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{framed}
\usepackage{color}
\usepackage{graphicx}
\usepackage[normalem]{ulem}
\usepackage{cancel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{geometry}
\usepackage{subfigure}
\geometry{a4paper, top=20mm, left=35mm, right=25mm, bottom=40mm}

\newcounter{tasknbr}
\setcounter{tasknbr}{1}
\newenvironment{task}[1]{{\bf Aufgabe \arabic {tasknbr}\stepcounter{tasknbr}} (#1):\begin{enumerate}}{\end{enumerate}}
\newcommand{\subtask}[1]{\item[#1)]}

% Listings -----------------------------------------------------------------------------
\definecolor{red}{rgb}{.8,.1,.2}
\definecolor{blue}{rgb}{.2,.3,.7}
\definecolor{lightyellow}{rgb}{1.,1.,.97}
\definecolor{gray}{rgb}{.7,.7,.7}
\definecolor{darkgreen}{rgb}{0,.5,.1}
\definecolor{darkyellow}{rgb}{1.,.7,.3}
\lstloadlanguages{C++,[Objective]C,Java}
\lstset{
escapeinside={§§}{§§},
basicstyle=\ttfamily\footnotesize\mdseries,
columns=fullflexible, % typewriter font look better with fullflex
keywordstyle=\bfseries\color{blue},
% identifierstyle=\bfseries,
commentstyle=\color{darkgreen},      
stringstyle=\color{red},
numbers=left,
numberstyle=\ttfamily\scriptsize\color{gray},
% stepnumber=5,
% numberfirstline=true,
breaklines=true,
% prebreak=\\,
showstringspaces=false,
tabsize=4,
captionpos=b,
% framexrightmargin=-.2\textwidth,
float=htb,
frame=tb,
frameshape={RYR}{y}{y}{RYR},
rulecolor=\color{black},
xleftmargin=15pt,
xrightmargin=4pt,
aboveskip=\bigskipamount,
belowskip=\bigskipamount,
backgroundcolor=\color{lightyellow},
extendedchars=true,
belowcaptionskip=15pt}

%% Enter current values here: %%
\newcommand{\lecture}{Algorithmische Geometrie SS15}
\newcommand{\tutor}{}
\newcommand{\assignmentnbr}{3}
\newcommand{\students}{Julius Auer, Alexa Schlegel}
%%-------------------------------------%%

\begin{document}  
\lstset{language=Java}
{\small \textsl{\lecture \hfill \tutor}}
\hrule
\begin{center}
\textbf{Übungsblatt \assignmentnbr}\\
[\bigskipamount]
{\small \students}
\end{center}
\hrule

\begin{task}{Graham-Scan}\item[]
\emph{Implementieren Sie den Graham-Scan. Benutzen Sie dabei aus Gründen besserer Laufzeit und zur Vermeidung von Rundungsfehlern möglichst nur die Grundrechenarten $+,-,\times, \div$. Eine Umrechnung in Polarkoordinaten, wie in der Vorlesung beschrieben, ist nicht nötig, um die Strahlen nach Steigung zu sortieren.}

Im Folgenden wird der implementierte Algorithmus mit Hilfe von Pseudocode beschreiben, dieser orientiert sich an der in \emph{Introduction to Algorithms}\footnote{Introduction to Algorithms, Second Edition, S. 949} vorgestellten Lösung. Der Stack $S$ wird verwendet, um mögliche Kandidaten der konvexen Hülle zu verwalten. Nach terminierung des Algorithmus enthält $S$ die Knoten der konvexen Hülle entgegen dem Urzeigersinn.

\begin{algorithm}
\caption{Graham-Scan(Q)}
\begin{algorithmic}[1]
\STATE sei $p_0 \in Q$ mit minimaler $y$-Koordinate:\\
bei gleicher $y$-Koordinate wird minimale $x$-Koordinate verwendet
\STATE sei ${p_1, p_2, \dots, p_n}$ die restlichen Punkte aus $Q$:\\
von $p_0$ aus gesehen in Polarkorrdinaten gegen den Urzeigersinn sortiert\\
bei gleichem Winkel, nur Punkt mit größtem Abstand von $p_0$ behalten\\
\STATE \textsc{Push}($p_0$, $S$)\\
\STATE \textsc{Push}($p_1$, $S$)\\
\STATE \textsc{Push}($p_2$, $S$)\\
\FOR{$i=3$ \TO $n$}
    \WHILE{Winkel (\textsc{Next-To-Top}($S$), \textsc{Top}($S$), $p_i$) ist keine Linkskurve}
    \STATE \textsc{Pop}($S$)
    \ENDWHILE
    \STATE \textsc{Push}($p_i$, $S$)
\ENDFOR
\RETURN{$S$}
\end{algorithmic}
\end{algorithm}

Die Methode \emph{grahamscan()} erhält als Eingabe eine Punktwolke und liefert ein Polygon zurück, welches der Konvexenhülle dieser Punktwolke entspricht.

Wir verwenden als Startpunkt des Algorithmus den Punkt der am weitestens Links liegt und die kleinsten $y$-Koordinte besitzt (\emph{getMinY()}). (In der Vorlesung wird ein beliebiebiger Punkt in der Mitte der Punktwolke ermittelt.)

Die Sortierung der Punkte erfolgt nach ihrer Steigung. Damit die Punkte gegen den Urzeigersinn sortiert sind werden sie vorher an der Funktion $f(x)=|x|$ gespiegelt und erst dann der Anstiegt berechnet (\emph{getRelevantPoints()}).

Um Links- und Rechskurven zu prüfen, wird die Determinante einer $2x2$-Matrix bestimmt, welche sich aus den zwei Vektoren der folgenden drei Punkte zusammensetzt. $t$ ist der letzte Punkt auf dem Stack, $ntt$ der vorletzte Punkt und $ca$ der Punkt der aktuelle betrachtet wird. Es wird getestet ob $\overline{t~cp}$ links oder rechts von $\overline{t~ntt}$ liegt.

\newpage

\lstinputlisting[language=Java, firstline=18, lastline=85]{../../AlGeo/src/algorithms/ConvexHull.java}

\lstinputlisting[language=Java, firstline=18, lastline=34]{../../AlGeo/src/geometry/Points.java}

\lstinputlisting[language=Java, firstline=36, lastline=66]{../../AlGeo/src/geometry/Points.java}

\newpage

Zur Veranschaulichung des Algorithmus gibt es einen Testklasse, wo die einzelnen Schritte visualisiert werden. Hier ein Beispiel mit 10 zufälligen Punkten:

\begin{figure}[h]
\begin{center}
\subfigure{
    \includegraphics[width=5cm]{capture1}
}
\subfigure{
    \includegraphics[width=5cm]{capture2}
}
\subfigure{
    \includegraphics[width=5cm]{capture3}
}
\subfigure{
    \includegraphics[width=5cm]{capture4}
}
\subfigure{
    \includegraphics[width=5cm]{capture5}
}
\subfigure{
    \includegraphics[width=5cm]{capture12}
}
\end{center}
\caption{Die ersten 5 Schritte und die resultierende Konvexehülle.}
\end{figure}

\end{task}

\begin{task}{inkrementelle Konstruktion der konvexen Hülle}\item[]
TODO
\end{task}

\begin{task}{untere Schranke}\item[]
TODO
\end{task}
\end{document}