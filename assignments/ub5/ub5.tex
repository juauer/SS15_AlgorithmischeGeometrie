% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

\documentclass[a4paper, titlepage=false, parskip=full-, 10pt]{scrartcl}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english, ngerman]{babel}
\usepackage{babelbib}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{framed}
\usepackage{color}
\usepackage{graphicx}
\usepackage[normalem]{ulem}
\usepackage{cancel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{geometry}
\usepackage{subfigure}
\geometry{a4paper, top=20mm, left=35mm, right=25mm, bottom=40mm}

\newcounter{tasknbr}
\setcounter{tasknbr}{1}
\newenvironment{task}[1]{{\bf Aufgabe \arabic {tasknbr}\stepcounter{tasknbr}} (#1):\begin{enumerate}}{\end{enumerate}}
\newcommand{\subtask}[1]{\item[#1)]}

% Listings -----------------------------------------------------------------------------
\definecolor{red}{rgb}{.8,.1,.2}
\definecolor{blue}{rgb}{.2,.3,.7}
\definecolor{lightyellow}{rgb}{1.,1.,.97}
\definecolor{gray}{rgb}{.7,.7,.7}
\definecolor{darkgreen}{rgb}{0,.5,.1}
\definecolor{darkyellow}{rgb}{1.,.7,.3}
\lstloadlanguages{C++,[Objective]C,Java}
\lstset{
escapeinside={§§}{§§},
basicstyle=\ttfamily\footnotesize\mdseries,
columns=fullflexible, % typewriter font look better with fullflex
keywordstyle=\bfseries\color{blue},
% identifierstyle=\bfseries,
commentstyle=\color{darkgreen},      
stringstyle=\color{red},
numbers=left,
numberstyle=\ttfamily\scriptsize\color{gray},
% stepnumber=5,
% numberfirstline=true,
breaklines=true,
% prebreak=\\,
showstringspaces=false,
tabsize=4,
captionpos=b,
% framexrightmargin=-.2\textwidth,
float=htb,
frame=tb,
frameshape={RYR}{y}{y}{RYR},
rulecolor=\color{black},
xleftmargin=15pt,
xrightmargin=4pt,
aboveskip=\bigskipamount,
belowskip=\bigskipamount,
backgroundcolor=\color{lightyellow},
extendedchars=true,
belowcaptionskip=15pt}

%% Enter current values here: %%
\newcommand{\lecture}{Algorithmische Geometrie SS15}
\newcommand{\tutor}{}
\newcommand{\assignmentnbr}{5}
\newcommand{\students}{Julius Auer, Alexa Schlegel}
%%-------------------------------------%%

\begin{document}  
{\small \textsl{\lecture \hfill \tutor}}
\hrule
\begin{center}
\textbf{Übungsblatt \assignmentnbr}\\
[\bigskipamount]
{\small \students}
\end{center}
\hrule

\begin{task}{Suchen in ebenen Unterteilungen}
\item[]
Für eine \emph{einfache} Datenstruktur kann durch jeden Knoten eine vertikale \emph{und} eine horizontale Linie gezogen werden. Es entstehen dabei zwar $n^2$ viele Gitterzellen, da bei einer Anfrage allerdings zunächst nur entlang einer Dimension ($n$ Reihen bzw. Spalten) und danach erst entlang der anderen Dimension gesucht wird, ist eine Zeitkomplexität von schlimmstenfalls nur $2\cdot\log n$ zu erwarten.

Es seien im Folgenden $G=(V,E,F)$ mit $|V|=n$ eine Unterteilung der Ebene mit Knoten, Kanten und Facetten, und $A$ ein 2-dimensionales Array der Größe $n\times n$ mit Tupeln $(x_{i,j},y_{i,j},f_{i,j})$ und der Eigenschaft, dass für alle $(x,y)\in\mathbb{R}^2$ gilt $(x,y)\in f_{i,j}\Leftrightarrow x_{i,j}\le x\wedge y_{i,j}\le y\wedge x<x_{i,j+1}\wedge y<y_{i+1,j}$. Es wird beim Erstellen der Datenstruktur also jedem Rechteck des Gitters durch alle Punkte die Facette der Unterteilung zugeordnet, die dieses Rechteck vollständig enthält.

\begin{algorithm}
\caption{$INIT(V, F, A)$}
\begin{algorithmic}[1]
\STATE{sort $V$ along $x$-coordinate}\\
\STATE{$i:=0$}\\
\FOR{$\text{ \bf each }v\in V$}
\STATE{$x_{0,i}:=v.x$}\\
\STATE{$i+=1$}\\
\ENDFOR
\STATE{sort $V$ along $y$-coordinate}\\
\STATE{$j:=0$}\\
\FOR{$\text{ \bf each }v\in V$}
\STATE{$y_{j,0}:=v.y$}\\
\STATE{$j+=1$}\\
\ENDFOR
\FOR{$\text{ \bf each }(x_{j,i},y_{j,i})\in A$}
\STATE{$f_{j,i}:=f\in F:(x_{j,i},y_{j,i})\in f$}\\
\ENDFOR
\end{algorithmic}
\end{algorithm}

Zeitkomplexität:
\begin{itemize}
\item Sortieren nach $x$ und ''benennen'' der Spalten (1-5) benötigt mit geeignetem Sortier-Algorithmus $O(n\cdot\log n)$
\item Sortieren nach $y$ und ''benennen'' der Zeilen (6-8) benötigt mit geeignetem Sortier-Algorithmus $O(n\cdot\log n)$
\item Um jedem Eintrag (naiv!) eine Facette zuzuordnen (11-13), kann jeweils über die gesamte Menge der Facetten iteriert werden und in konstanter Zeit festgestellt werden, ob ein Punkt der Facette im Rechteck liegt, das von $(x_{j,i},y_{j,i}),(x_{j+1,i+1},y_{j+1,i+1})$ aufgespannt wird. Die Anzahl Facetten ist asymptotisch begrenzt durch die Anzahl der Knoten. Insgesamt kostet diese Zuordnung somit $O(n^3)$ Zeit. Dieser Aufwand dominiert die zuvor erwähnten Kosten.
\end{itemize}

\newpage
Speicherkomplexität:
$O(n^2)$ für das Array, das den Rechtecken des Gitters jeweils eine Facette zuordnet.

Suchen wird nun durch eine Binärsuche entlang der x-Koordinate und eine zweite entlang der y-Koordinate realisiert. Im Array findet sich die zugehörige Facette. Der Algorithmus ist trivial und die Zeitkomplexität offensichtlich $O(\log n)$.
\end{task}

\begin{task}{$L_1$-Voronoi-Diagramme}
\item[]
In $L_1$-Metrik beschreiben die Punkte mit Abstand $d$ von einem Punkt ein Quadrat mit Seitenlänge $2\cdot d$ (Abb. \ref{fig:l1_1}).
\begin{figure}[h]
\begin{center}
\includegraphics[width=3cm]{capture0}
\end{center}
\caption{Punkte mit Abständen 1,2,3 von einem Punkt liegen auf den Ränder dieser Quadrate}
\label{fig:l1_1}
\end{figure}

Eine zwei Voronoi-Regionen trennende Kante hat nun stets eine von drei möglichen Formen, welche vom Verhältnis zwischen der X-Differenz und der Y-Differenz der Punkte bestimmt wird. Dominiert die X-Differenz, wird die Kante senkrecht ''aussehen''. Dominiert die Y-Differenz, wird die Kante waagerecht ''aussehen''.

Es sind im Folgenden die drei Fälle abgebildet, dass bei zwei Punkten die Y-Differenz (Abb. \ref{fig:l1_2}), die X-Differenz (Abb. \ref{fig:l1_3}) oder keine der beiden (Abb. \ref{fig:l1_4}) dominiert.

Jede Abbildung zeigt die drei untergeordneten Fälle, bei denen der in der dominanten Dimension größere Punkt in der rezesiven Dimension kleiner/gleich/größer dem anderen Punkt ist. Andere Fälle als die gezeigten sieben kann es nicht geben.

\begin{figure}[h]
\begin{center}
\subfigure{
\includegraphics[width=3cm]{capture1}
}
\subfigure{
\includegraphics[width=3cm]{capture2}
}
\subfigure{
\includegraphics[width=3cm]{capture3}
}
\end{center}
\caption{Fall 1: $\left|\frac{x_1-x_2}{y_1-y_2}\right| <1$}
\label{fig:l1_2}
\end{figure}

\begin{figure}[h]
\begin{center}
\subfigure{
\includegraphics[width=3cm]{capture4}
}
\subfigure{
\includegraphics[width=3cm]{capture5}
}
\subfigure{
\includegraphics[width=3cm]{capture6}
}
\end{center}
\caption{Fall 2: $\left|\frac{x_1-x_2}{y_1-y_2}\right| >1$}
\label{fig:l1_3}
\end{figure}

\begin{figure}[h]
\begin{center}
\includegraphics[width=3cm]{capture7}
\end{center}
\caption{Fall 3: $\left|\frac{x_1-x_2}{y_1-y_2}\right| =1$}
\label{fig:l1_4}
\end{figure}

Auffälig ist hier der letzte, entartete Fall, bei dem eine Menge von Punkten (rot) zu beiden Punkten equidistant ist und keine Kante sondern eine Fläche beschreibt. Wie dieser Fall im Kontext von Voronoi-Diagrammen behandelt werden sollte ist nicht aus deren Definition abzuleiten. In der Praxis sollte dieser Fall jedoch ohnehin nur relevant sein, wenn mit Ganzzahligen Koordinaten gerechnet wird.
\end{task}

\newpage
\begin{task}{Suche in ebenen Unterteilungen - Verallgemeinerung}
\item[]

Die Lokalisierungsdatenstruktur (LDS) wurde in der Vorlesung als gerichteter azyklischer Graph (DAG) beschrieben und funktioniert für ebene Unterteilungen, wo jede Facette ein Dreieck ist, auch die Außenfacette.

Wir werden nun im ersten Schritt aus der beliebigen Unterteilung der Ebene eine Triangulierung erzeugen einem Dreieck als Außenfacette. Im zweiten Schritt wenden wir darauf den in der Vorlsung vorgestellten Algorithmus zur Konstruktion der LDS an.

\begin{enumerate}
\item Um die vorhandene Unterteilung $U$ ein großes Dreieck $D$ legen, sodass alle Strecken im Inneren des Dreicks liegen.
\item Schnittpunkte von $D$ mit Strahlen der Unterteilung $U$ als Knoten in $U$aufnehmen.
\item Eckpunkte des Dreiecks auch in $U$ aufnehmen.
\item Inneres von $U$ Triangulieren $\rightarrow G$.
\item Algorithmus zur Konstruktion der LDS($G$) anwenden.
\end{enumerate}

Folgendes wurde in der Vorlesung definiert:

\begin{itemize}
\item eingebetteter Graph $G$ entspricht $S_1$
\item $S_h$ ist das äußere, umschließende Dreieck
\item $h=O(\log n)$
\item $I$ ist die unabhängige Knotenmenge
\end{itemize}

\begin{algorithm}
\caption{Algorithmus zur Konstruktion der LDS($G$)}
\begin{algorithmic}[1]
\STATE Sei $S_1=G$
\STATE Für jedes $\triangle$ in $G$ erzeuge einen Knoten in LDS($G$)
\STATE i = 1
\WHILE {$|S_i|>3$}
    \STATE {Berechne von $I$}
    \STATE {Entferne $I$ aus $S_i$}
    \STATE {Trianguliere $S_i \setminus I \rightarrow S_i+1$}
    \STATE {für jedes neue $\triangle$ $t$ in $S_i+1$ erzeuge einen Knoten K($t$)in LDS($G$) und füge eine Kante von K($t$) zu allen Knoten von Dreiecken von $S_i$ die von  $t$ geschnitten werden}
    \STATE {i++}
\ENDWHILE
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Lokalisiere ($q$, LDS($G$))}
\begin{algorithmic}[1]
\IF {$q \not \in S_h$}
		\RETURN {$q$ liegt in Außenfacette}
\ENDIF
\STATE {$v$=Wurzel(LDS($G$))}
\WHILE {$v$ hat Nachfolger}
		\FORALL {Nachfolger $u$ von $v$}
    		\IF {$q$ ist in Dreieck von $u$}
    				\STATE {$v=u$}
    		\ENDIF
		\ENDFOR
\ENDWHILE
\RETURN {$q$ liegt im Dreieck von $v$}
\end{algorithmic}
\end{algorithm}

\begin{description}
\item[Vorverarbeitungszeit]
Ich schätze das Dreieck drumrumbauen dauert $O(n)$, weil man irgendwie das min-$x$, max-$x$ finden muss um das Dreieck zu konstruieren? Das Berechnen der Schnittpunkte kann man vernachlässigen.\\
$\rightarrow O(n)$
\item[Speicherbedarf]
Es kommen nur konstant viele Knoten hinzu. 3 Knoten für das Dreieck und noch ein paar Schnittpunkte. Also bleibt es bei dem was in der Vorlesung gesagt wurde.\\
$\rightarrow O(n)$
\item[Anfragezeit]
Bleibt gleich, oder?\\
$\rightarrow O(\log n)$
\end{description}


\end{task}
\end{document}