% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

\documentclass[a4paper, titlepage=false, parskip=full-, 10pt]{scrartcl}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english, ngerman]{babel}
\usepackage{babelbib}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{framed}
\usepackage{color}
\usepackage{graphicx}
\usepackage[normalem]{ulem}
\usepackage{cancel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{geometry}
\usepackage{subfigure}
\geometry{a4paper, top=20mm, left=35mm, right=25mm, bottom=40mm}

\newcounter{tasknbr}
\setcounter{tasknbr}{1}
\newenvironment{task}[1]{{\bf Aufgabe \arabic {tasknbr}\stepcounter{tasknbr}} (#1):\begin{enumerate}}{\end{enumerate}}
\newcommand{\subtask}[1]{\item[#1)]}

% Listings -----------------------------------------------------------------------------
\definecolor{red}{rgb}{.8,.1,.2}
\definecolor{blue}{rgb}{.2,.3,.7}
\definecolor{lightyellow}{rgb}{1.,1.,.97}
\definecolor{gray}{rgb}{.7,.7,.7}
\definecolor{darkgreen}{rgb}{0,.5,.1}
\definecolor{darkyellow}{rgb}{1.,.7,.3}
\lstloadlanguages{C++,[Objective]C,Java}
\lstset{
escapeinside={§§}{§§},
basicstyle=\ttfamily\footnotesize\mdseries,
columns=fullflexible, % typewriter font look better with fullflex
keywordstyle=\bfseries\color{blue},
% identifierstyle=\bfseries,
commentstyle=\color{darkgreen},      
stringstyle=\color{red},
numbers=left,
numberstyle=\ttfamily\scriptsize\color{gray},
% stepnumber=5,
% numberfirstline=true,
breaklines=true,
% prebreak=\\,
showstringspaces=false,
tabsize=4,
captionpos=b,
% framexrightmargin=-.2\textwidth,
float=htb,
frame=tb,
frameshape={RYR}{y}{y}{RYR},
rulecolor=\color{black},
xleftmargin=15pt,
xrightmargin=4pt,
aboveskip=\bigskipamount,
belowskip=\bigskipamount,
backgroundcolor=\color{lightyellow},
extendedchars=true,
belowcaptionskip=15pt}

%% Enter current values here: %%
\newcommand{\lecture}{Algorithmische Geometrie SS15}
\newcommand{\tutor}{}
\newcommand{\assignmentnbr}{5}
\newcommand{\students}{Julius Auer, Alexa Schlegel}
%%-------------------------------------%%

\begin{document}  
{\small \textsl{\lecture \hfill \tutor}}
\hrule
\begin{center}
\textbf{Übungsblatt \assignmentnbr}\\
[\bigskipamount]
{\small \students}
\end{center}
\hrule

\begin{task}{Suchen in ebenen Unterteilungen}
\item[]
Für eine \emph{einfache} Datenstruktur kann durch jeden Knoten eine vertikale \emph{und} eine horizontale Linie gezogen werden. Es entstehen dabei zwar $n^2$ viele Gitterzellen, da bei einer Anfrage allerdings zunächst nur entlang einer Dimension ($n$ Reihen bzw. Spalten) und danach erst entlang der anderen Dimension gesucht wird, ist eine Zeitkomplexität von schlimmstenfalls nur $2\cdot\log n$ zu erwarten.

Es seien im Folgenden $G=(V,E,F)$ mit $|V|=n$ eine Unterteilung der Ebene mit Knoten, Kanten und Facetten, und $A$ ein 2-dimensionales Array der Größe $n\times n$ mit Tupeln $(x_{i,j},y_{i,j},f_{i,j})$ und der Eigenschaft, dass für alle $(x,y)\in\mathbb{R}^2$ gilt $(x,y)\in f_{i,j}\Leftrightarrow x_{i,j}\le x\wedge y_{i,j}\le y\wedge x<x_{i,j+1}\wedge y<y_{i+1,j}$. Es wird beim Erstellen der Datenstruktur also jedem Rechteck des Gitters durch alle Punkte die Facette der Unterteilung zugeordnet, die dieses Rechteck vollständig enthält.

\begin{algorithm}
\caption{$INIT(V, F, A)$}
\begin{algorithmic}[1]
\STATE{sort $V$ along $x$-coordinate}\\
\STATE{$i:=0$}\\
\FOR{$\text{ \bf each }v\in V$}
\STATE{$x_{0,i}:=v.x$}\\
\STATE{$i+=1$}\\
\ENDFOR
\STATE{sort $V$ along $y$-coordinate}\\
\STATE{$j:=0$}\\
\FOR{$\text{ \bf each }v\in V$}
\STATE{$y_{j,0}:=v.y$}\\
\STATE{$j+=1$}\\
\ENDFOR
\FOR{$\text{ \bf each }(x_{j,i},y_{j,i})\in A$}
\STATE{$f_{j,i}:=f\in F:(x_{j,i},y_{j,i})\in f$}\\
\ENDFOR
\end{algorithmic}
\end{algorithm}

Zeitkomplexität:
\begin{itemize}
\item Sortieren nach $x$ und ''benennen'' der Spalten (1-5) benötigt mit geeignetem Sortier-Algorithmus $O(n\cdot\log n)$
\item Sortieren nach $y$ und ''benennen'' der Zeilen (6-8) benötigt mit geeignetem Sortier-Algorithmus $O(n\cdot\log n)$
\item Um jedem Eintrag (naiv!) eine Facette zuzuordnen (11-13), kann jeweils über die gesamte Menge der Facetten iteriert werden und in konstanter Zeit festgestellt werden, ob ein Punkt der Facette im Rechteck liegt, das von $(x_{j,i},y_{j,i}),(x_{j+1,i+1},y_{j+1,i+1})$ aufgespannt wird. Die Anzahl Facetten ist asymptotisch begrenzt durch die Anzahl der Knoten. Insgesamt kostet diese Zuordnung somit $O(n^3)$ Zeit. Dieser Aufwand dominiert die zuvor erwähnten Kosten.
\end{itemize}

\newpage
Speicherkomplexität:

$O(n^2)$ für das Array, das den Rechtecken des Gitters jeweils eine Facette zuordnet.

Suchen wird nun durch eine Binärsuche entlang der x-Koordinate und eine zweite entlang der y-Koordinate realisiert. Im Array findet sich die zugehörige Facette. Der Algorithmus ist trivial und die Zeitkomplexität offensichtlich $O(\log n)$.
\end{task}

\begin{task}{$L_1$-Voronoi-Diagramme}
\item[]
In $L_1$-Metrik beschreiben die Punkte mit Abstand $d$ von einem Punkt ein Quadrat mit Seitenlänge $2\cdot d$ (Abb. \ref{fig:l1_1}).
\begin{figure}[h]
\begin{center}
\includegraphics[width=3cm]{capture0}
\end{center}
\caption{Punkte mit Abständen 1,2,3 von einem Punkt liegen auf den Ränder dieser Quadrate}
\label{fig:l1_1}
\end{figure}

Eine zwei Voronoi-Regionen trennende Kante hat nun stets eine von drei möglichen Formen, welche vom Verhältnis zwischen der X-Differenz und der Y-Differenz der Punkte bestimmt wird. Dominiert die X-Differenz, wird die Kante senkrecht ''aussehen''. Dominiert die Y-Differenz, wird die Kante waagerecht ''aussehen''.

Es sind im Folgenden die drei Fälle abgebildet, dass bei zwei Punkten die Y-Differenz (Abb. \ref{fig:l1_2}), die X-Differenz (Abb. \ref{fig:l1_3}) oder keine der beiden (Abb. \ref{fig:l1_4}) dominiert.

Jede Abbildung zeigt die drei untergeordneten Fälle, bei denen der in der dominanten Dimension größere Punkt in der rezesiven Dimension kleiner/gleich/größer dem anderen Punkt ist. Andere Fälle als die gezeigten sieben kann es nicht geben.

\begin{figure}[h]
\begin{center}
\subfigure{
\includegraphics[width=3cm]{capture1}
}
\subfigure{
\includegraphics[width=3cm]{capture2}
}
\subfigure{
\includegraphics[width=3cm]{capture3}
}
\end{center}
\caption{Fall 1: $\left|\frac{x_1-x_2}{y_1-y_2}\right| <1$}
\label{fig:l1_2}
\end{figure}

\begin{figure}[h]
\begin{center}
\subfigure{
\includegraphics[width=3cm]{capture4}
}
\subfigure{
\includegraphics[width=3cm]{capture5}
}
\subfigure{
\includegraphics[width=3cm]{capture6}
}
\end{center}
\caption{Fall 2: $\left|\frac{x_1-x_2}{y_1-y_2}\right| >1$}
\label{fig:l1_3}
\end{figure}

\begin{figure}[h]
\begin{center}
\includegraphics[width=3cm]{capture7}
\end{center}
\caption{Fall 3: $\left|\frac{x_1-x_2}{y_1-y_2}\right| =1$}
\label{fig:l1_4}
\end{figure}

Auffälig ist hier der letzte, entartete Fall, bei dem eine Menge von Punkten (rot) zu beiden Punkten equidistant ist und keine Kante sondern eine Fläche beschreibt. Wie dieser Fall im Kontext von Voronoi-Diagrammen behandelt werden sollte ist nicht aus deren Definition abzuleiten. In der Praxis sollte dieser Fall jedoch ohnehin nur relevant sein, wenn mit Ganzzahligen Koordinaten gerechnet wird.
\end{task}

\newpage
\begin{task}{Suche in ebenen Unterteilungen - Verallgemeinerung}
\item[]

Die Lokalisierungsdatenstruktur (LDS) wurde in der Vorlesung als gerichteter azyklischer Graph (ADG) beschrieben und funktioniert für Triangulierung von $G$ mit Dreieck als Außenfacette.

$S_1$ entspricht $G$, also der ebenen Unterteilung  (eingebetteter Graph)
$S_n$ ist das äußere (umschließende) Dreieck

Ich habe es so verstanden dass in jedem Schritt die unabhänige Knotenmenge bestimmt und entfert wird, dass sind dann die $S_i$'s' die zwischen 1 und n konstruiert werden.

Eine Knotenmenge $I$ von $G$ (Teilmenge) heißt unabhängig, wenn keine zwei Knoten aus $I$ in $G$ durch eine Kante verbungen sind. Es geht wohl in linearer Zeit zu berechnen, weil warum auch immer, wurde in VL bewiesen.




1. vorher das Ding Triangulieren\\
2. großes Dreieck drumrum bauen\\
3. wenn ein Strahl das äußerer Dreieck schneidet, dann dort einen neuen Knoten einfügen\\
4. Eckpunkte vom Dreieck mit Punkten verbinden oder einfach nochmal Triangulieren? oder voher schon Dreicke rumbasteln

die beiden algorithmen wurden in der VL vorgestellt, diese dann noch ein bischen erweitern.

\begin{algorithm}
\caption{Algorithmus zur Konstruktion}
\begin{algorithmic}[1]
\STATE Sei $S_1=G$
\STATE Für jedes $\triangle$ in $G$ erzeuge einen Knoten in LDS($G$)
\STATE i = 1
\WHILE{$|S_i|>3$}
    \STATE{Berechne $I$}
    \STATE {Entferne $I$ aus $S_i$}
    \STATE {Trianguliere $S_i ohne I$, das ist dann $S_i+1$}
    \STATE {für jedes neue $\triangle$ $t$ in $S_i+1$ erzeuge einen Knoten K($t$)in LDS($G$), füge eine Kante von K($t$) zu allen Knoten von Dreiecken von $S_i$ die von  $t$ geschnitten werden}
    \STATE i++
\ENDWHILE
\end{algorithmic}
\end{algorithm}


h ... log(n)

\begin{algorithm}
\caption{Lokalisiere (q, LDS(G))}
\begin{algorithmic}[1]
\STATE teste ob $q \in S_h$ falls nein gib aussenfassette zurück
\STATE $v$=Wurzel(LDS(G))
\WHILE{$v$ hat Nachfolger}
    \STATE { für jeden Nachfolger von $u$ von $v$ teste ob $q$ im Dreiech $u$ liegt.}
    \STATE {Falls ja, setze $v=u$ und wiederhole}
\RETURN {$q$ liegt im Dreieck von $v$}
\ENDWHILE
\end{algorithmic}
\end{algorithm}

* Erweiterung von LDS\\
* Algorithmen zur Suche und Konstruktion anpassen\\
* alle Unterteilungen den Ebene sollen unterstützt werden (mehrere unbeschränkte Facetten)\\
* Einzelheiten der Algorithmen beschreiben\\
*Vorverarbeitungszeit, Speicherbedarf, Anfragezeit, Anhängig von Anzahl der Knoten\\ 

\end{task}
\end{document}